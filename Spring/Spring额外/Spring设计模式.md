[toc]

## 第一天

#### 1. Spring涉及的设计模式

回答：
1.工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
2.代理设计模式 : Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术。
3.单例设计模式 : Spring 中的 Bean 默认都是单例的。
4.模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
5.包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
6.观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。
7.适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。



#### 2. MySQL的 binlog 有有几种录入格式？分别有什么区别？ 

回答：
有三种格式，statement，row 和 mixed

statement 模式下，每一条会修改数据的 SQL 都会记录在 binlog 中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于 SQL 的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
row 级别下，不记录 SQL 语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如 alter table)，因此这种模式的文件保存的信息太多，日志量太大。
mixed，一种折中的方案，普通操作使用 statement 记录，当无法使用 statement 的时候使用row 。此外，新版的 MySQL 中对 row 级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。



#### 3. Java常见的垃圾收集器有哪些？

典型回答：
实际上，垃圾收集器（GC，Garbage Collector）是和具体 JVM 实现紧密相关的，不同厂商（IBM、Oracle），不同版本的 JVM，提供的选择也不同。聊聊 5 种最主流的 Oracle JDK。

1、Serial GC，它是最古老的垃圾收集器。
“Serial” 体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的 “Stop-The-World” 状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。
从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。Serial GC 的对应 JVM 参数是：`-XX:+UseSerialGC`

2、ParNew GC，很明显是个新生代 GC 实现。
它实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC 工作，下面是对应参数：`-XX:+UseConcMarkSweepGC` `-XX:+UseParNewGC`



3、CMS（Concurrent Mark Sweep） GC，基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要。
一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。



4、Parallel GC，在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。
它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。开启选项是：`-XX:+UseParallelGC`

另外，Parallel GC 引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM 会自动进行适应性调整，例如下面参数：

```java
-XX:MaxGCPauseMillis=value
-XX:GCTimeRatio=N  // GC时间和用户时间比例 = 1/(N+1)
```



5、G1 GC 这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。
G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。





G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。
G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。



## 第二天

#### 1. 给定一个无向图 graph，当这个图为二部图时返回 true。

提示：如果能将一个图的节点集合分割成两个独立的子集 A 和 B，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为二部图。

解题思路：
判断一个给定的任意图是否为二部图，就必须要对该图进行一次遍历：
1、深度优先
2、广度优先
二部图，图的所有顶点可以分成两个子集 U 和 V，子集里的顶点互不直接相连，图里面所有的边，一头连着子集 U 里的顶点，一头连着子集 V 里的顶点。

1、给图里的顶点涂上颜色，子集 U 里的顶点都涂上红色，子集 V 里的顶点都涂上蓝色。
2、开始遍历这个图的所有顶点，想象一下手里握有红色和蓝色的画笔，每次交替地给遍历当中遇到的顶点涂上颜色
3、如果这个顶点还没有颜色，那就给它涂上颜色，然后换成另外一支画笔。
4、下一个顶点，如果发现这个顶点已经涂上了颜色，而且颜色跟我手里画笔的颜色不同，那么表示这个顶点它既能在子集 U 里，也能在子集 V 里。
5、所以，它不是一个二部图。

```java
// 首先遍历出邻接表
Node[] nodes = new Node[length]; // nodes三种状态 -1，0，1
//初始化邻接表
List[] array[] =  new ArrayList<>();
// DFS遍历（用栈，或递归）
// BFS遍历
```



#### 2. 线程的状态有哪些？ 它是如何工作的？

(1) 操作系统进程状态：创建、就绪、阻塞、运行、终止。

注意：创建和退出不是进程的状态。阻塞和就绪的区别：阻塞是等待除CPU以外的资源，而就绪等待的是CPU资源。

(2) Java线程包括6个状态：**新建、就绪、阻塞、等待、计时等待、终止**

1、NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；

2、RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；

3、BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；  

4、WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；

5、TIMED_WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；

6、TERMINATED，终止状态，表示线程已经执行完成。

<img src="资源\图1.jpg" style="zoom:67%;" />

#### 3. 举例说明什么情况下会更倾向于使用抽象类而不是接口？

1、在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了，当你使用接口时，你的类就可以同时拥有多个不同的行为。（LinkedList => List、Deque、AbstractCollection）

2、如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。（定义程序执行顺序）



#### 4. MySQL 存储引擎 MyISAM 与 InnoDB 区别？

存储引擎 Storage engine：MySQL 中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。

1、Innodb 引擎：Innodb 引擎提供了对数据库 ACID 事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
2、MyIASM 引擎(原本 MySQL 的默认引擎)：不提供事务的支持，也不支持行级锁和外键。
3、MEMORY 引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。



#### 5. Java 的内存模型是什么？

JVM 试图定义一种统一的内存模型，能将各种底层硬件以及操作系统的内存访问差异进行封装，使 Java 程序在不同硬件以及操作系统上都能达到相同的并发效果。它分为工作内存和主内存，线程无法对主存储器直接进行操作，如果一个线程要和另外一个线程通信，那么只能通过主存进行交换，如下图所示。



<img src="资源\图2.jpg" style="zoom:60%;" />



## 第三天

#### 1. Mybatis最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？

Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值。
接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement。

举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。
Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。

#### 2. HashMap 底层是如何实现的？在 JDK 1.8 中它都做了哪些优化？

在 JDK 1.7 中 HashMap 是以数组加链表的形式组成的，JDK 1.8 之后新增了红黑树的组成结构，当链表大于 8 并且容量大于 64 时，链表结构会转换成红黑树结构，它的组成结构如下图所示：

<img src="资源\图3.jpg" style="zoom:67%;" />

数组中的元素我们称之为哈希桶，它的定义如下：

可以看出每个哈希桶中包含了四个字段：hash、key、value、next，其中 next 表示链表的下一个节点。

JDK 1.8 之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。

1、JDK 1.8 HashMap 扩容时做了哪些优化？
2、加载因子为什么是 0.75？
3、当有哈希冲突时，HashMap 是如何查找并确认元素的？
4、HashMap 源码中有哪些重要的方法？
5、HashMap 是如何导致死循环的？

#### 3. 如何监控和诊断 JVM 堆内和堆外内存使用？

1、可以使用综合性的图形化工具，如 JConsole、VisualVM（注意，从 Oracle JDK 9 开始，VisualVM 已经不再包含在 JDK 安装包中）等。这些工具具体使用起来相对比较直观，直接连接到 Java 进程，然后就可以在图形化界面里掌握内存使用情况。

以 JConsole 为例，其内存页面可以显示常见的堆内存和各种堆外部分使用状态。

2、也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。或者，也可以使用 jmap 等提供的命令，生成堆转储（Heap Dump）文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。

3、如果你使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。

4、另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息。
这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用 JDK 自带的 Native Memory Tracking（NMT）特性，它会从 JVM 本地内存分配的角度进行解读。

#### 4. 请列举出在JDK中几个常用的设计模式？

1、单例模式：保证被创建一次，节省系统开销。
2、工厂模式（简单工厂、抽象工厂）：解耦代码。
3、观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。
4、外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。

5、模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。
6、状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
7、装饰器设计模式：（Decorator design pattern）被用于多个 Java IO 类中

## 额外知识
#### 1.Spring框架的理解

Spring框架的核心思想就是抽象，IOC和AOP时核心功能。从整体来看Spring框架，可以抽离出几大核心顶级接口：BeanDefinetionReader、BeanFactoryPostProcesser、PostPrecesser、BeanFactory、FactoryBean和Environment，这些接口依次负责Bean的配置信息读取、增强、装载以及环境变量依赖，这几个接口就是Spring框架的核心。

Spring中Bean的声明周期，可以看AbstractApplicationContext的refresh方法，debug通读，大致流程：先经历一堆xxxAware把Bean需要的Spring组件调用各种setXxx给bean(比如setApplicationContext)，然后执行前置增强，也就是postprocesser的beforeinitializing；执行完后就开始初始化bean，初始化方法，然后后置增强，接着disposebean，最后destory。值得注意的是，postprocesser是有顺序的，定了priorityOrder的会先被执行，然后再执行带了order的。

#### 2. 抽象类和接口有哪些相同点和不同点
相同点：
（1） 都不能被实例化
（2）接口的实现类或抽象类的子类都必须实现抽象发布方法

不同点： 
（1）接口只有定义，不能有方法的实现，java1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现
（2）单继承多实现，接口中的变量均为public static final，必须有初值并且不能修改；抽象类中的成员变量为default可以被修改，抽象方法不能被private、static、native、synchrionzed修饰
（3）接口常用来约定、规范功能，便于维护添加具体的实现类，抽象类倾向于充当公共方法模板的角色，不适用于频繁修改的代码类。
（4）接口定义行为，抽象类即定义行为也负责实现